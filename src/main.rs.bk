extern crate taglib;
use taglib::Tag;
extern crate regex;
use regex::Regex;

use std::env::args;
use std::process::exit;

#[derive(Debug)]
enum CMD {
    Album, SetAlbum(String),
    Artist, SetArtist(String),
    Comment, SetComment(String),
    Genre, SetGenre(String),
    Title, SetTitle(String),
    Track, SetTrack(String),
    Year, SetYear(String),
}

fn main() {
    let mut args: Vec<_> = args().collect();
    if args.len() <= 2 {
        show_help(&args);
    }
    args.remove(0);
    let fname: String = args.remove(0);
    let it = args.iter();
    let mut cmds = Vec::new();
    for str in it {
        use CMD::*;
        cmds.push(match parse_cmd(str, "album") {
            Some(Some(s)) => SetAlbum(s),
            Some(None) => Album,
            _ => match parse_cmd(str, "artist") {
                Some(Some(s)) => SetArtist(s),
                Some(None) => Artist,
                _ => match parse_cmd(str, "comment") {
                    Some(Some(s)) => SetComment(s),
                    Some(None) => Comment,
                    _ => match parse_cmd(str, "genre") {
                        Some(Some(s)) => SetGenre(s),
                        Some(None) => Genre,
                        _ => match parse_cmd(str, "title") {
                            Some(Some(s)) => SetTitle(s),
                            Some(None) => Title,
                            _ => match parse_cmd(str, "track") {
                                Some(Some(s)) => SetTrack(s),
                                Some(None) => Track,
                                _ => match parse_cmd(str, "year") {
                                    Some(Some(s)) => SetYear(s),
                                    Some(None) => Year,
                                    _ => show_help(&args),
                                }
                            }
                        }
                    }
                }
            }
        });
    }
    let file = match taglib::File::new(&fname) {
        Ok(f) => f,
        Err(e) => {
            println!("Invalid file {}.  Error: {:?}", fname, e);
            exit(2);
        }
    };
    let tags = match file.tag() {
        Ok(t) => t ,
        Err(e) => {
            println!("No available tags for {}.  Error: {:?}", fname, e);
            exit(3);
        }
    };
}

// return type means outer Option is for parsed correctly,
// inner Option is for whether to set or display
fn parse_cmd(cmd: &String, expected: &str) -> Option<Option<String>> {
    let mut ci = cmd.chars();
    let mut ei = expected.chars();
    loop {
        match (ci.next(), ei.next()) {
            (None, None) => return Some(None),
            (Some('='), None) => return Some(Some(ci.collect())),
            (Some(c), Some(e)) => if c == e { continue; } else { return None; },
            _ => return None,
        }
    }
}

fn show_help(args: &Vec<String>) -> ! {
    println!("Usage: {} <file> [commands]", args[0]);
    println!("");
    println!("If no commands are present it will print out 'ARTIST - TITLE'.");
    println!("Normally using `artist title` would print out:\nARTIST\nTITLE");
    println!("");
    println!("Commands:");
    println!("  album                 Print out the album of the track");
    println!("  album=ALBUM           Sets the album of the track to ALBUM");
    println!("  artist                Print out the artist of the track");
    println!("  artist=ARTIST         Sets the artist of the track to ARTIST");
    println!("  comment               Print out the comment of the track");
    println!("  comment=COMMENT       Sets the comment of the track to COMMENT");
    println!("  genre                 Print out the genre of the track");
    println!("  genre=GENRE           Sets the genre of the track to GENRE");
    println!("  title                 Print out the title of the track");
    println!("  title=TITLE           Sets the title of the track to TITLE");
    println!("  track                 Print out the track number of the track");
    println!("  track=TRACK_NUMBER    Sets the track number of the track to TRACK_NUMBER");
    println!("  year                  Print out the year of the track or 0 if it isn't present");
    println!("  year=YEAR             Sets the year of the track to YEAR");
    exit(1);
}
